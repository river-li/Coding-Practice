# 练习用刷题源码

已将原本的Project-Euler、Leetcode以及WOJ整合

## 字符串

### 字符串旋转

给定字符串s和整数n

输出将字符串s前n个字母移到字符串末尾的结果

#### 临时字符串

用一个临时的字符串储存前n位

之后将字符串重新赋值

时间复杂度$O(n+m)$

空间复杂度$O(m)$


#### 三步翻转

首先将字符串分成前半部分和后半部分

分别对前半部分和后半部分调用翻转函数

最后对整体调用翻转函数

例如：
> abcdef, n=2
> bafedc
> cdefab

这里需要注意，由于一般用`sizeof()`得到的结果还会包含'\0'

因此为了防止`'\0'`翻转导致前半部分无法输出，需要在调用函数时对长度进行减一

### 字符串包含

给定一个字符串a和一个字符串b

判断b中的字母是否都在a中出现

#### Bruteforce

对短字符串的每一个字符在长字符串中轮询

复杂度$O(m*n)$

#### 先排序在轮询

首先对两个字符串排序，好的排序算法排序复杂度为$O(mlogm)+O(nlogn)$

之后在轮询，最坏的情况只需要$O(m+n)$

因此合计的复杂度为$O(mlogm)+O(nlogn)+O(m+n)$

多数情况下复杂度还是小于第一种方法的


#### 换为素数

资料里还提供了一个不可行的思路

将每一个字母转化成一个素数，将这个字符串表示为素数的乘积

如果两个大素数可以整除则说明字符全部包含

但是实际上前16个字母组成的素数相乘结果就已经非常大了，会超过long long int


### 字符串全排列
给定一个字符串要求输出其中所有字符的排列

#### next_permutation

C++的STL库中内置了这个算法

以一个数字为例"23145"，其下一个数字应该是"23154"

这个思路是

1. 从左向右找到最后一个升序的序列的首位，即"45"的4

2. 找到这个位置后面比它大的数字，即5

3. 交换这两个数字，变为45

4. 把这个位置+1处，直到最后的部分翻转即5-5的位置，翻转还是5

再举一个例子，例如"21543",这个数字的下一个数字应该是"23145"

得到的过程应该是：

1. 首先找到1，因为1后面存在比1 大的数字，是一个能增大的位，而543降序排列无法增大

2. 找到1后面比1大的最小数字3

3. 交换1,3 得到"23541"

4. 分析可以得知应该是一个"23xxx"的数字，而"xxx"应该是从小到大的排序

5. 因此541翻转即可得到正序排序

最后翻转即可得到正序的原因是最初1的位置往后一定是倒序排列

而1和比它大的最小数字换位置后，后面那部分还应该是倒序排列

因此翻转后变成正序
