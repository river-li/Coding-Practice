# 练习用刷题源码

已将原本的Project-Euler、Leetcode以及WOJ整合

## 字符串

### 字符串旋转

给定字符串s和整数n

输出将字符串s前n个字母移到字符串末尾的结果

#### 临时字符串

用一个临时的字符串储存前n位

之后将字符串重新赋值

时间复杂度$O(n+m)$

空间复杂度$O(m)$


#### 三步翻转

首先将字符串分成前半部分和后半部分

分别对前半部分和后半部分调用翻转函数

最后对整体调用翻转函数

例如：
> abcdef, n=2
> bafedc
> cdefab

这里需要注意，由于一般用`sizeof()`得到的结果还会包含'\0'

因此为了防止`'\0'`翻转导致前半部分无法输出，需要在调用函数时对长度进行减一

### 字符串包含

给定一个字符串a和一个字符串b

判断b中的字母是否都在a中出现

#### Bruteforce

对短字符串的每一个字符在长字符串中轮询

复杂度$O(m*n)$

#### 先排序在轮询

首先对两个字符串排序，好的排序算法排序复杂度为$O(mlogm)+O(nlogn)$

之后在轮询，最坏的情况只需要$O(m+n)$

因此合计的复杂度为$O(mlogm)+O(nlogn)+O(m+n)$

多数情况下复杂度还是小于第一种方法的


#### 换为素数

资料里还提供了一个不可行的思路

将每一个字母转化成一个素数，将这个字符串表示为素数的乘积

如果两个大素数可以整除则说明字符全部包含

但是实际上前16个字母组成的素数相乘结果就已经非常大了，会超过long long int

