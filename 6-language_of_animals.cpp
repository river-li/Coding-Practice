/* Date:        2019-03-09
 * Generated by River-li
 * Language:    C++14
 */

#include<vector>
#include<iostream>
#include<cstdio>
#include<queue>

using namespace std;
//Class Animal
class Animal{
public:
    Animal(int val);
    bool visited=false;
    int distance=-1;
    vector<int> communicate;
    int val;
};

Animal::Animal(int val){
    this->val=val;
}

//Animal ENDS
//
//Class Graph
class Graph{
public:
    Graph(int size);
    int size;
    void connect(int a,int b);
    int search(int source,int destination);
    vector<Animal> ani;
};

Graph::Graph(int size){
    this->size=size;
    for(int i=0;i<size;i++){
        Animal tmp(i);
        this->ani.push_back(tmp);
    }
}

void Graph::connect(int a,int b){
    this->ani[a].communicate.push_back(b);
    this->ani[b].communicate.push_back(a);
}

int Graph::search(int source,int destination){
    for(int i=0;i<this->size;i++){
        this->ani[i].visited=false;
        this->ani[i].distance=-1;
    }
    this->ani[source].visited=true;
    this->ani[source].distance=0;

    queue<int> q;
    q.push(source);
    int d=0;

    while(!q.empty()){
        int tmp=q.front();
        q.pop();
        if(tmp==destination)
            return this->ani[tmp].distance;

        for(int i=0;i<this->ani[tmp].communicate.size();i++){
            if(this->ani[this->ani[tmp].communicate[i]].visited==false)
            {
                this->ani[this->ani[tmp].communicate[i]].visited=true;
                this->ani[this->ani[tmp].communicate[i]].distance=d;
                q.push(this->ani[tmp].communicate[i]);
            }
        }
        d++;
    }
    return -1;
}
//Graph ENDS

//Main Here
int main()
{
    int m,n,k,a1,a2,q1,q2,result;
    scanf("%d %d",&n,&m);
    Graph g(n);
    for(int i=0;i<m;i++){
        scanf("%d %d",&a1,&a2);
        g.connect(a1, a2);
    }

    scanf("%d",&k);
    for(int i=0;i<k;i++){
        scanf("%d %d",&q1,&q2);
        result=g.search(q1,q2);
        printf("%d",result);
    }
    return 0;
}

